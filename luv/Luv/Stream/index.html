<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Stream (luv.Luv.Stream)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../index.html">luv</a> &#x00BB; <a href="../index.html">Luv</a> &#x00BB; Stream</nav><header class="odoc-preamble"><h1>Module <code><span>Luv.Stream</span></code></h1><p>Streams.</p><p>See <a href="../../../networking.html#tcp"><i>TCP</i></a> in the user guide and <a href="http://docs.libuv.org/en/v1.x/stream.html"><code>uv_stream_t</code> <i>— Stream handle</i></a> in libuv.</p><p>Several types of <a href="../Handle/index.html#type-t" title="Luv.Handle.t">handle</a> have a portion of their interface in common, which portion is abstracted out into this module <a href="#"><code>Luv.Stream</code></a>.</p><p>Concrete streams are:</p><ul><li><a href="../Pipe/index.html#type-t"><code>Luv.Pipe.t</code></a></li><li><a href="../TCP/index.html#type-t"><code>Luv.TCP.t</code></a></li><li><a href="../TTY/index.html#type-t"><code>Luv.TTY.t</code></a></li></ul></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'kind t</span></span><span> = <span><span>[ <span>`Stream of <span class="type-var">'kind</span></span> ]</span> <a href="../Handle/index.html#type-t">Handle.t</a></span></span></code></div><div class="spec-doc"><p>Binds <a href="http://docs.libuv.org/en/v1.x/stream.html#c.uv_stream_t"><code>uv_stream_t</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-shutdown"><a href="#val-shutdown" class="anchor"></a><code><span><span class="keyword">val</span> shutdown : <span><span><span class="type-var">_</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span><span>(unit, <a href="../Error/index.html#type-t">Error.t</a>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Shuts down the write side of the stream.</p><p>Binds <a href="http://docs.libuv.org/en/v1.x/stream.html#c.uv_shutdown"><code>uv_shutdown</code></a>. See <a href="http://man7.org/linux/man-pages/man3/shutdown.3p.html"><code>shutdown(3p)</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-listen"><a href="#val-listen" class="anchor"></a><code><span><span class="keyword">val</span> listen : 
  <span><span class="optlabel">?backlog</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">_</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span><span>(unit, <a href="../Error/index.html#type-t">Error.t</a>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Starts listening for incoming connections.</p><p>Binds <a href="http://docs.libuv.org/en/v1.x/stream.html#c.uv_listen"><code>uv_listen</code></a>. See <a href="http://man7.org/linux/man-pages/man3/listen.3p.html"><code>listen(3p)</code></a>.</p><p>The default value of <code>?backlog</code> is <code>SOMAXCONN</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-accept"><a href="#val-accept" class="anchor"></a><code><span><span class="keyword">val</span> accept : <span><span class="label">server</span>:<span><span class="type-var">'kind</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">client</span>:<span><span class="type-var">'kind</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(unit, <a href="../Error/index.html#type-t">Error.t</a>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>Accepts an incoming connection.</p><p>Binds <a href="http://docs.libuv.org/en/v1.x/stream.html#c.uv_accept"><code>uv_accept</code></a>. See <a href="http://man7.org/linux/man-pages/man3/accept.3p.html"><code>accept(3p)</code></a>.</p><p><code>~client</code> should be a freshly-initialized stream of the same kind as <code>~server</code>. In other words, if <code>~server</code> is a <a href="../TCP/index.html#type-t"><code>Luv.TCP.t</code></a>, <code>~client</code> should also be a <a href="../TCP/index.html#type-t"><code>Luv.TCP.t</code></a>, and should have been obtained from <a href="../TCP/index.html#val-init"><code>Luv.TCP.init</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-read_start"><a href="#val-read_start" class="anchor"></a><code><span><span class="keyword">val</span> read_start : 
  <span><span class="optlabel">?allocate</span>:<span>(<span>int <span class="arrow">&#45;&gt;</span></span> <a href="../Buffer/index.html#type-t">Buffer.t</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">_</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span><span>(<a href="../Buffer/index.html#type-t">Buffer.t</a>, <a href="../Error/index.html#type-t">Error.t</a>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Calls its callback whenever data is available on the stream.</p><p>Binds <a href="http://docs.libuv.org/en/v1.x/stream.html#c.uv_read_start"><code>uv_read_start</code></a>. See <a href="http://man7.org/linux/man-pages/man3/read.3p.html"><code>read(3p)</code></a>.</p><p>The amount of data read is equal to the length of the buffer passed to the callback.</p><p><code>?allocate</code> is called immediately before each call to the main callback with <code>Ok buffer'</code>, to create <code>buffer</code>, into which the data will be read. <code>buffer'</code> is, in general, a <a href="../Buffer/index.html#val-sub" title="Luv.Buffer.sub">view</a> into <code>buffer</code>. The default <code>?allocate</code> allocates a fresh buffer every time it is called. One particular use of <code>?allocate</code> is to always read data into the same pre-existing buffer. The <code>int</code> argument passed to <code>?allocate</code> is a suggested size. It is acceptable to return a buffer of a smaller size. To read into an existing buffer, but not at its beginning, use <a href="../Buffer/index.html#val-sub"><code>Luv.Buffer.sub</code></a> to create a view into the buffer.</p><p>The end of the stream (typically, when the remote peer closes or shuts down the connection) is indicated by <code>Error `EOF</code> being passed to the callback. Note that this behavior is different from <a href="../File/index.html#val-read"><code>Luv.File.read</code></a>.</p><p>Zero-length reads are possible, and do not indicate the end of stream. Instead, they usually indicate <code>EAGAIN</code> inside libuv; libuv still calls the callback in order to give the C user a chance to deallocate the data buffer. This is not usually an issue in OCaml, so a wrapper of this function can usually simply ignore zero-length reads. It is then also safe to convert <code>Error `EOF</code> to zero-length reads in a higher-level API, for consistency with reading files, and in accordance with OS API convention.</p><p>To read only once, call <a href="#val-read_stop"><code>Luv.Stream.read_stop</code></a> immediately, in the main callback. Otherwise, the main callback will be called repeatedly.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-read_stop"><a href="#val-read_stop" class="anchor"></a><code><span><span class="keyword">val</span> read_stop : <span><span><span class="type-var">_</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(unit, <a href="../Error/index.html#type-t">Error.t</a>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>Stops reading.</p><p>Binds <a href="http://docs.libuv.org/en/v1.x/stream.html#c.uv_read_stop"><code>uv_read_stop</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-write"><a href="#val-write" class="anchor"></a><code><span><span class="keyword">val</span> write : 
  <span><span><span class="type-var">_</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Buffer/index.html#type-t">Buffer.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span><span>(unit, <a href="../Error/index.html#type-t">Error.t</a>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Writes the given buffer to the stream.</p><p>Binds <a href="http://docs.libuv.org/en/v1.x/stream.html#c.uv_write"><code>uv_write</code></a>. See <a href="http://man7.org/linux/man-pages/man3/writev.3p.html"><code>writev(3p)</code></a>.</p><p>To write only part of a buffer, use <a href="../Buffer/index.html#val-sub"><code>Luv.Buffer.sub</code></a> to create a view into the buffer, and pass the view to this function <a href="#val-write"><code>Luv.Stream.write</code></a>.</p><p>The second argument passed to the callback is the number of bytes written. libuv has an internal queue of writes, in part to implement retry. This means that writes can be partial at the libuv (and Luv) API level, so it is possible to receive both an <code>Error</code> result, and for some data to have been successfully written.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-write2"><a href="#val-write2" class="anchor"></a><code><span><span class="keyword">val</span> write2 : 
  <span><span><span>[&lt; `Pipe ]</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Buffer/index.html#type-t">Buffer.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">send_handle</span>:<span><span>[&lt; `TCP <span>| `Pipe</span> ]</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span><span>(unit, <a href="../Error/index.html#type-t">Error.t</a>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Like <a href="#val-write"><code>Luv.Stream.write</code></a>, but allows sending a TCP socket or pipe over the stream (<code>~send_handle</code>). The stream must be a pipe.</p><p>Binds <a href="http://docs.libuv.org/en/v1.x/stream.html#c.uv_write2"><code>uv_write2</code></a>.</p><p>See <a href="../Pipe/index.html#val-receive_handle"><code>Luv.Pipe.receive_handle</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-try_write"><a href="#val-try_write" class="anchor"></a><code><span><span class="keyword">val</span> try_write : <span><span><span class="type-var">_</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Buffer/index.html#type-t">Buffer.t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(int, <a href="../Error/index.html#type-t">Error.t</a>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>Like <a href="#val-write"><code>Luv.Stream.write</code></a>, but only attempts to perform the write operation immediately.</p><p>Binds <a href="http://docs.libuv.org/en/v1.x/stream.html#c.uv_try_write"><code>uv_try_write</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-try_write2"><a href="#val-try_write2" class="anchor"></a><code><span><span class="keyword">val</span> try_write2 : 
  <span><span><span>[&lt; `Pipe ]</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Buffer/index.html#type-t">Buffer.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">send_handle</span>:<span><span>[&lt; `TCP <span>| `Pipe</span> ]</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(int, <a href="../Error/index.html#type-t">Error.t</a>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>Like <a href="#val-write2"><code>Luv.Stream.write2</code></a>, but only attempts to perform the write operation immediately.</p><p>Binds <a href="http://docs.libuv.org/en/v1.x/stream.html#c.uv_try_write2"><code>uv_try_write2</code></a>.</p><p>Requires Luv 0.5.9 and libuv 1.42.0.</p><p><a href="../Require/index.html" title="Luv.Require">Feature check</a>: <code>Luv.Require.(has try_write2)</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_readable"><a href="#val-is_readable" class="anchor"></a><code><span><span class="keyword">val</span> is_readable : <span><span><span class="type-var">_</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Indicates whether the given stream is readable (has data).</p><p>Binds <a href="http://docs.libuv.org/en/v1.x/stream.html#c.uv_is_readable"><code>uv_is_readable</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_writable"><a href="#val-is_writable" class="anchor"></a><code><span><span class="keyword">val</span> is_writable : <span><span><span class="type-var">_</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Indicates whether the given stream is writable (has space in buffers).</p><p>Binds <a href="http://docs.libuv.org/en/v1.x/stream.html#c.uv_is_writable"><code>uv_is_writable</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_blocking"><a href="#val-set_blocking" class="anchor"></a><code><span><span class="keyword">val</span> set_blocking : <span><span><span class="type-var">_</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="arrow">&#45;&gt;</span></span> <span><span>(unit, <a href="../Error/index.html#type-t">Error.t</a>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>Sets the blocking mode of a stream.</p><p>Binds <a href="http://docs.libuv.org/en/v1.x/stream.html#c.uv_stream_set_blocking"><code>uv_stream_set_blocking</code></a>.</p></div></div></div></body></html>
